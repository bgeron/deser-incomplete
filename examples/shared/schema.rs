use clap::ValueEnum;
use serde::{Deserialize, Serialize};

use super::format::{Format, ParseResult, ParseSettings};

/// The schema that the output should conform to.
///
/// Schemas (code generated by `#[derive(Deserialize)]`) can significantly change the
/// result -- both larger (because `#[serde(default)]` adds fields) and smaller (when
/// an incomplete list element isn't parseable at all).
#[derive(Debug, Clone, ValueEnum, Default)]
pub enum Schema {
    /// Any JSON value.
    #[default]
    Any,
    /// A list of structs with mode and benefit fields, both strings.
    TravelModes,
}

#[derive(Debug, Default, Deserialize, Serialize, PartialEq)]
struct TravelMode {
    #[serde(default)]
    mode: String,
    benefit: Option<String>,
}

impl Schema {
    pub fn parse(&self, format: &Format, settings: &ParseSettings, input: &[u8]) -> ParseResult {
        match self {
            Schema::Any => format.parse::<serde_json::Value>(settings, input),
            Schema::TravelModes => format.parse::<Vec<TravelMode>>(settings, input),
        }
    }
}
